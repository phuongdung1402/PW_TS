
--B19: TestInfor & Tag

Phần 1: Testinfo
B1: Gõ npx playwright test ...
B2: Tổng hợp : đọc config -> đọc file test
B3: Phân công : gọi worker (os process)
B4: Tạo hồ sơ : Runner ( PW Test runner) tạo ra 1 cái object gọi là testnfor. điền hết thông tin
title , project , worker, retry,...
B5: Injection -> cho vào tham số thứ 2 của hàm test ({page, fixtureA, fixtureB}, testInfor)

--Tìm hiểu thêm trong web PW->testInfor

Nhóm chức năng : Lấy thông tin (Read only)
Title : tên bài test 
Project.name : tên project
file_ : đường dẫn file test
retry : số lần chạy lại
status : trạng thái của file test thường dùng ở after each
duration : thời gian chạy : thường dùng ở after each

Nhóm chức năng : Điều khiển luồng
-testInfor.skip() : bỏ qua file test
-testInfor.setTimeout()
-testInfor.fail()


Nhóm chức năng : báo cáo
testInfor.attach(): chụp bất kì lúc nào 
testInfor.annotation.push 
---------------------------------------------------------------------------------------
Nguồn để test infor lấy : trong file test, trong file config playwright, lúc chạy test (run time)
Lấy đc thông tin của lúc chạy file test (run time )-> lấy được status . duration

--------------------------------------------------------------------------------------
Phạm vị (testInfor)
Tầng global:
-Testinfor ko có phạm vi gloabal ( vì nó là tham số thứ 2 của file test)

-Tầng group (describe)

-Tầng function (testInfor mới đc sinh ra )

Config test :
-Phạm vi global: 
test.setTimeout()
test.skip()
test.slow()

-Phạm vi group:
test.describe()

-Phạm vi function : dùng đc testInfor và cả test 


Quy tắc ghi đè khi sử dụng test và testinfor ở nhóm chức năng điều khiển luồng
-> Càng vào sâu ( scope hẹp hơn ) thì càng có quyên lực cao hơn

Phần 2: Tags

Để chạy ta sẽ dùng --grep "@tag"

-g "@tag"

--grep-invert "@tag" -> chạy bài test bỏ qua thằng @tag



--------------------B20-------------------------
- Có 3 giai đoạn khi mà chúng ta gõ : npx playwright test ....
-GD1 : Main process - chương trình chính ( Quét file )
-Đăng kí các file test (ghi danh )
-Ở đây main process ko chạy hàm async ({page})
-> sau khi đọc hết xong -> có 1 danh sách tổng -(vdu : ghi lại trong file này có 1 bài test tên là test A .. Dòng số 10..thuộc scenario...)
tiếp đến phụ thuộc vào filter mà chúng ta đưa cho: --grep (tag) , tên file...folder...
-Nó sẽ tính toán cần bao nhiêu worker (cái này phụ thuộc vào setup của ng dùng hoặc default tự tính toán)
-Chia việc : ...


-GD2: Worker làm việc
-Main process ko gửi code mà gửi mệnh lệnh qua kênh IPC (Cơ chế inter process communication)

-GD3: Worker process -người thợ
-Khởi động , nó như 1 tờ giấy trắng nhận lệnh và bắt đầu làm việc
-Load lại file (re-evaluation) và check lại vs file test mệnh lệnh từ main process -> nếu đúng nhảy vào cái ruột body , 
nếu sai skip luôn

Lưu ý:
*** GlobalSetup và GlobalTeardown là chạy 2 worker riêng biệt ko phụ thuộc vào test 
*** BeforeAll & AfterAll : phụ thuộc vào worker ( nếu trong quá trình chạy mà worker chết thì code của phần AfterAll sẽ ko chạy đc )

=>> Main process : load hết file -> gửi mệnh lệnh. Worker load hết lại file so sánh vs mệnh lệnh: đúng thì làm , còn ko thì ko làm


DATA DRIVEN 
Có 1 bộ data -> mình sẽ chạy hết các info trong bộ data đối với 1 testcase
Vdu : test login vs 1 bộ dữ liệu ( giá trị biên, min , max lengh)
-Nếu viết file test thì thông thường ta sẽ phải viết bằng ấy file test tương ứng vs số dữ liệu
-Dùng 1 bộ test -> sử dụng vòng lặp chạy qua các dữ liệu và chạy vào file test

Nguyên tắc vàng : dữ liệu dùng để sinh test (parameter) phải là dữ liệu tĩnh(static) hoặc đồng bộ ở tại thời điểm chạy lệnh
( đồng bộ data từ main xuống worker để chạy)


---------------------------------------
Chạy parallel (song song) : sẽ giúp tốc độ nhanh gấp N lần (N = số lượng worker /CPU của máy)

+Hệ thống nhà hàng 
Main process: quản lí nhà hàng
worker process: là đầu bếp
File test(.spec.ts) : sách công thức

Nguyên tắc:
1.Quy tắc sắp xếp file (thực đơn từ A-Z)
ví dụ file nào có bắt đầu bằng chữ A sẽ sắp trên cùng ưu tiên nhất -> Z (Theo thứ tự alphabet)

Ví dụ ở hệ thống nhà hàng có 3 file :
01_A.spec.ts 
02_B.spec.ts
03_C.spec.ts 

2. Cơ chế phân chia worker (Ai nahnh hưởng nhiều)
Ví dụ : ta có 2 worker : 1 và 2 
-Cảnh 1 phân chia ban đầu 
-> 2 đầu bếp tới bảng công việc
worker 1 nhanh hơn -> 01_A.spec.ts

worker 2 chạy tới cái thứ 2 -> 02_B.spec.ts

-Cảnh 2 : Chênh lệch tốc độ
Worker 1 chạy test 01_A.spec.ts rất nhanh -> làm xong trong 2 phút
Worker 2 chạy test 02_B.spec.ts lâu hơn -> mất 5ph

-Cảnh 3 : Quay lại hàng chờ (queue)
Worker 1 chạy nốt 03_C.spec.ts

=> Cuối cùng
worker 1 : món 1 + 3
worker 2 : món 2

Có 2 cấp độ : 
1 cấp độ file test
2 cấp độ testcase ở trong file test



---------------B21 ----------------------
Traceview : là tập hợp các snapshot dom
Flaky test : test chập chờn

Khi deploy code lên PROD -> ở 1 số cty hiện đại và có quy trình chuẩn -> trigger Automation test (pipeline)
với bộ TCs regression test liên quan tới CR golive đó -> nếu mà chạy regress fail -> deploy bị block và ko chạy nữa
BE/FE phải đợi chờ ngồi lại 10-15 

cơ chế "Tự chữa lành" tạm thời để hệ thống vận hành trơn tru

Alure Report
-Có thể lưu history rất nhiều lần chạy
-Install Allure report : npm install -g allure
npm i allure-playwright
npm i allure-js-commons


Sau khi chạy test vs allure xong , chạy tiếp : allure generate ./allure-result -o ./allure-report 
allure open ./allure-report



------------B22 : API-------------------
API = Application Programming Interface 
Application : là giống các phần mềm fb , zl 
programming : là cách chúng đc viết ra bằng code
Interface : là nơi gặp gỡ , cầu nối để 2 thằng xa lạ nch đc vs nhau
=> Cách giao tiếp giữa FE và BE
-B1 : FE đưa request (process) 
-B2 : BE Response

I.Hiện nay có những công nghệ nào để API sử dụng:
1.Restful API : theo chuẩn restful API (Thay thế SOAP API : dùng xml )
endpoint : phần sau domain
(Vdu :
Trên máy bán nc có nút A(coca), B(pepsi) ,.. đc gọi là endpoint.Ví dụ muốn dùng coca -> ấn nút A -> nhả ra lon coca)

->Vấn đề với restful API : 
+Thừa mức sẽ gây phí phạm (tốn băng thông) ( Ví dụ máy nhả 330ml , uống có 1 ngụm sau đó ném đi )
+Mất công : thao tác 2 lần gửi 2 request (Vdu: coca + bimbim => sẽ phải ấn 2 lần , 1 lần coca, 1 lần bimbim
 => phải thao tác 2 lần gửi 2 request)

2.GraphQL (Do fb phát triển )
-BE
FE tự đưa yêu cầu và gửi xuống BE 
Ưu điểm: Chính xác-> yêu cầu gì đc nấy , ko bị dư thừa. Tiện lợi : nếu cần thêm gì đều có thể thêm đc.
BE sẽ mang ra trong 1 request

3.Websocket:
Cách hoạt động : socket connection (data stream)
-Ko cần qua bên thứ 3
Ứng dụng : coin, giá vàng ( ko có độ trễ hoặc độ trễ thấp )

Cơ chế của playwright : websocket : giao tiếp trực tiếp vs browser


II.Ngôn ngữ chung : giúp BE & FE giao tiếp đc vs nhau là JSON (Javascript object notation)
-Cấu trúc JSON rất đơn giản , giống vs typescript

vd 
{ 
    "ten": "An",
    "tuoi": 25
}

Cơ chế website : Client side , Server side
-Thông tin 1 request mà FE gọi xuống BE : 
1.Method (hành động muốn làm) => dán tem lên bì thư để định danh hành động
-Get : lấy thông tin (ko sửa đổi gì )Ví dụ xem danh sách sản phẩm
-Post : tạo mới (đăng kí tài khoản)
-Put/patch: sửa đổi ( ví dụ đổi mật khẩu, cập nhật profile)
-Delete : xóa giỏ hàng
=> CURD create update read delete


2.Endpoint (Địa chỉ ) 
BaseUrl : https://jsonplaceholder.typicode.com
endpoint: /todos/1

3.Headers (thông tin phụ) -> những thứ viết bên ngoài phong bì
-Content-type : application/json (báo trc : trong thư là viết bằng json)
-Authorization : xác thực và phân quyền (cho cơ chế JWT)

4.Body (nội dung thư)
Chỉ dùng cho Post , Put/patch


-Sử dụng CURL -> giống như 1 gói tin nén đầy đủ URL , endpoint , method, header, body....trong 1 đoạn văn bản duy nhất

-Thông tin response phản hồi : 
1. Status code ( mã trạng thái ) -> cực kì quan trọng
2xx (thành công)
200 : ok - get
201 : Created (tạo mới thành công) - post

3xx
Redirect - chuyển hướng


4xx (lỗi)
400 : bad request (gửi dữ liệu sai format)
401 : Unauthorized (chưa đăng nhập)
403 : Forbidden (đăng nhập rồi nhưng ko có quyền)
404 : Not found (sai địa chỉ) (thường sai endpoint)

5xx (lỗi server)
500 :Internal server error
502 setTimeout


-Response body 
Dữ liệu server trả về(thường là Json) để FE lấy ra 
Fixture sử dụng là request (API Context) ->playwright độ riêng cho chúng ta sử dụng để call API, giống như thg page thì 
dùng cho UI


-------------B33: Nền tảng giao thức API--------------
Authentication và Authorization và cơ chế JWT
Authentication : xác thực bạn là ai (401)
Authorization : bạn đc làm gì (403)

route
/admin/dashboard
/guest/dashboard

jwt (json web token)-token base (có thể dễ dàng dùng trên web hay mobile - multi device)

session based (stateful) -cookie base ( hay dùng trên web, ít dùng trên mobile)
jwt (stateless) 

Cấu trúc jwt ( 3 phần )
phần 1: header ( chứa thông tin về thuật toán mã hóa)
phần 2: payload (chứa dữ liệu mà server muốn gửi, thường là thông tin user) (mã hóa ở dạng base64)
phần 3: chữ kí bảo mật (đây là phần đảm bảo tính toàn vẹn , server sẽ tạo ra chữ kí bằng công thức 
Sign=hash(header +payload+ secretkey) )

exp :expired (cơ chế bảo mật)
Khi token hết hạn , client (FE) sẽ âm thầm sử dụng refreshToken để xin server cấp lại 1 access token mới mà user ko hề biết

//Clean API 
--Để có 1 clean pattern API framework, chúng ta phải chia nhỏ các module thành những phần reuse cho các mục đích khác nhau
API : Sẽ chia các API thuộc 1 nhóm thành 1 service()
mô hình nguyên khối tất cả các module tập hợp thành 1 khối to ( ví dụ : payment, noti, ekyc). Khi 1 module nhỏ chết -> cả nguyên
khối đều chết theo.
Để giải quyết vấn đề của mô hình nguyên khối, ngta sử dụng mô hình microservices :
mô hình microservices => chia nhỏ các module thành các service khác nhau, mỗi service sẽ quản lí 1 công việc của riêng nó
các khối liên kết bởi cầu nối API(restful api, grpc, GraphQL), mô hình pub/sub (rabbit mq , kafka..., event message)

-Mình sẽ cần 1 thằng chung chia sẻ các method, mà các thành phần con có thể sử dụng
Ví dụ như service Product : chỉ quan tâm tới việc : get thông tin sản phẩm, tạo sp,upload ảnh sản phẩm,.. mà nó ko cần biết
gì về việc call api như nào,...

--Để thực hiện lưu token cho các bài test đối với API:
Chúng ta cần lưu trực tiếp vào file với phần trích xuất jwt -token và sẽ xử lí đọc file đó để lấy token

-GET : lấy dữ liệu
-POST : tạo mới dữ liệu
-PUT/PATCH : bản chất là thay đổi thông tin của đối tượng đã có trong database

Put: sẽ thay đổi toàn bộ thông tin của sản phẩm và yêu cầu phải đầy đủ body truyền lên. nếu truyền thiếu thì trường 
đó mặc định trả về null -> hoặc về default tùy nghiệp vụ.
Có những trường required bắt buộc phải đẩy lên -> ví dụ như tên sản phẩm

Patch : sẽ thay đổi thông tin của sản phẩm theo body truyền lên mà ko ảnh hưởng tới các thông tin khác, nghĩa là
ta muốn thay đổi 

---------------------------------------------------------------------------------------------------------------------
1.Intercept là gì 
-Gọi API từ FE xuống BE
-Intercept : chặn request từ FE xuống BE, trả lại cho ng dùng cái response giả mà mình yêu cầu
( mock : giả lập response trả ra từ BE cho FE)


2.Why ?? (Lợi ích của việc sử dụng intercept)
-Speed : (tốc độ) : ko chờ server xử lí , ko chờ mạng .Response trả về tức thì
-Dữ liệu sạch : ko tạo data rác trong database
-Kiểm thử kịch bản khó (edge case) : giả lập đc những thứ server rất khó làm như server sập (500), mạng lag, lỗi dữ liệu (409)
( Ví dụ : Hệ thống core : giống như trading, bank => sẽ là hệ thống trung tâm cung cấp tất cả yêu cầu cho các hệ thống vệ tinh >
ko thể nào test để case server sập 500 )
-Ổn định : bởi vì cta giả lập response -> loại bỏ yếu tố do mạng lag hay server bảo trì

3.Để thực hiện intercept trong playwright sử dụng :
await page.route('duong dan api muon chan', async (route)=> {
    logic xu ly o day
})


-----
PW có 1 feature rất hay đc gọi là waitForResponse() : đợi BE trả về cho FE
//Hay dùng cho các tác vụ chạy nền như là download, upload, auto save

word văn bản (sau 10s chẳng hạn word sẽ tự động save) -> có 1 số web có chức năng auto save (ở dưới nền - ko có UI để tương tác)
